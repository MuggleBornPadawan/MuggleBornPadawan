#+title: the ultimate guide to software development fundamentals
* introduction
** core dump
- program vs process
- memory: stack, heap, data and text
** fp
- optional types
- errors as values
- parse, donâ€™t validate
- smart constructor
- newtypes
- phantom types
- functional core, imperative shell
- algebraic data types
- monadic operations
- pattern matching
- higher-order functions
- lazy evaluation
- immutable data structures
- functor and applicative styles
- type classes
- recursion schemes
** developer productivity
- space metrics - https://getdx.com/blog/space-metrics/ - satisfaction and well-being, performance, activity, communication and collaboration, efficiency and flow
- devops research and assessment (dora) group - deployment frequency (df), lead time for changes (lt4c), mean time to recover (mttr), change failure rate (cfr)
** clean code
clean code requires:
- meaningful names: variables, functions, and classes must clearly state *why* they exist, *what* they do, and *how* they are used. avoid abbreviations unless universally understood within the domain.
- small units: functions should do one thing, and do it well. aim for functions that fit on a screen (ideally fewer than 20 lines).
- minimal dependencies: functions should rely on as few external components as possible. favor pure functions (no side effects).
- clear abstraction levels: within a single function, all statements should operate at the same level of abstraction. do not mix high-level intent with low-level implementation details.
- avoid duplication (dry): identical or highly similar code blocks must be extracted into a shared abstraction.
- error handling as primary flow: errors must be handled explicitly and near the point where they can occur. do not pass error codes; use exceptions or return values that clearly signal failure.
- no comments for bad code: if code requires explanation, refactor the code until the explanation is unnecessary. comments should only explain *why* (intent/policy), not *what* (implementation).
- consistency: maintain uniform formatting, naming conventions, and structural patterns throughout the codebase.
in clojure/lisp contexts, this translates to: concise forms, well-defined namespaces, appropriate use of macros versus functions, and careful management of state via atoms/refs/agents rather than hidden mutations. focus on immutability
** devops
|------------+--------------------------------------|
| tool       | description                          |
|------------+--------------------------------------|
| linux      | runs 96% of production servers       |
| docker     | containerizes your apps              |
| kubernetes | orchestrates everything              |
| terraform  | manages your infrastructure          |
| jenkins    | automates your deployments           |
| prometheus | monitors your systems                |
| grafana    | visualizes your metrics              |
| ansible    | configures your servers              |
| nginx      | serves your applications to millions |
|------------+--------------------------------------|
** system design   
|-----------------------+------------------------------------------------------------------------------------------+--------------------------------------------------------------------------|
| aspect                | key metrics                                                                              | popular open source tools                                                |
|-----------------------+------------------------------------------------------------------------------------------+--------------------------------------------------------------------------|
| scalability           | requests per second (rps), cpu/memory utilization %, latency @ n users                   | kubernetes, docker, openstack                                            |
| availability          | uptime % (e.g., 99.99%), mtbf (mean time between failures), mttr (mean time to recovery) | kubernetes, haproxy, keepalived                                          |
| latency vs throughput | latency (p50, p95, p99 in ms), throughput (rps, tps)                                     | nginx, envoy, netty                                                      |
| data consistency      | replication lag (seconds/ms), consistency models (strong, eventual)                      | postgresql (strong), cassandra (eventual), zookeeper (coordination)      |
| caching               | cache hit ratio %, cache miss rate %, latency of cache lookups                           | redis, memcached, varnish                                                |
| database modeling     | query execution time (ms), index hit rate %                                              | postgresql (relational), mongodb (document), mysql                       |
| load balancing        | request distribution per node, cpu/memory load per node, active connections              | nginx, haproxy, envoy proxy                                              |
| failover & redundancy | mttr (mean time to recovery), failover success rate %                                    | kubernetes, patroni (for postgresql), pacemaker                          |
| security              | vulnerabilities found/patched, mttd/mttr for incidents, auth error rates                 | hashicorp vault, owasp zap, openssl, keycloak                            |
| observability         | the "four golden signals": latency, traffic, errors, saturation                          | prometheus, grafana, jaeger, elk stack (elasticsearch, logstash, kibana) |
| idempotency           | duplicate transaction/event count, error rate on retried requests                        | rabbitmq, kafka, stripe api (as an implementation example)               |
|-----------------------+------------------------------------------------------------------------------------------+--------------------------------------------------------------------------|
* best practices
** software development principles
- key variables: system integrity, adaptablity, cognitive load, efficiency, risk mitigation, collaboration
- modularity and single responsiblity
- loose coupling
- dont repeat yourself
- keep it simple, stupid
- you aren't going to need it
- testablity & verification
- open / closed principle
- embrace change and iteration
** technical fundamentals
- key variables: computational logic, data representation, problem solving abstraction, resource management, algorithmic efficiency, system interaction
*** language of computers
- binary system
- boolean logic
- data representation
*** how programs run
- memory models
- cpu and instructions
- operating system basics
*** organizing data and solving problems
- core data structures
- fundamental algorithms
- algorithmic complexity (big o)
*** communication and systems
- networking basics
- file systems
- command line interface
*** development lifecycle
- compilation vs interpretation
- version control
* software development fundamentals
** understand the problem deeply
** design for clarity and modularity
- single responsiblity principle
- modular design
- dont repeat yourself (dry)
** quality and reliablity
- test driven development
- strategic error handling & exception management
- defensive programming
** idempotency
** embrace maintainablity and evolution
- code comments & documentation
- disciplined refactoring
- configuration management & environment variables
** foster collaboration and transparency
- version control & smart branching strategies
- code reviews & pair programming
- robust logging & monitoring
** performance and security
- profiling
- security by design
- clear licensing and author information
* common mistakes
- ignoring version control
- hardcoding everything
- "big ball of mud" anti pattern
- skipping tests
- premature optimization
- ignoring error handling
- "my code is self-explanatory"
- fear of refactoring 

#+title: apis
* components checklist
- endpoints, request methods, headers, request body, response body, status codes, authentication and authorization, rate limiting, versioning, documentation 
** endpoints
- access path for client. RESTful API: https://api.example.com/users
** request methods
- these are the HTTP methods used to perform actions on the resources. common methods include:
  - GET: retrieve data from the server
  - POST: send data to the server to create a new resource
  - PUT: update an existing resource on the server
  - DELETE: remove a resource from the server
** headers
- headers are key-value pairs sent with the API request and response. they provide metadata about the request or response.
- common headers:
  - content-Type: indicates the media type of the resource (e.g., application/json)
  - authorization: contains credentials for authenticating the request
** request body
- the request body contains data sent to the server when making POST or PUT requests. it is often formatted in JSON or XML
** response body
- the response body contains data returned from the server. tt is typically formatted in JSON or XML
** status codes
- status codes are part of the HTTP response and indicate the result of the request. common status codes:
  - 200 OK: the request was successful
  - 201 Created: a new resource was successfully created
  - 400 Bad Request: the request was invalid or cannot be served
  - 401 Unauthorized: authentication is required and has failed or has not been provided
  - 404 Not Found: the requested resource could not be found
  - 500 Internal Server Error: an error occurred on the server
** authentication and authorization
- mechanisms to ensure that only authorized users can access certain endpoints or perform certain actions. common methods:
  - API Keys: simple tokens that are passed in the request header
  - OAuth: a more secure method that involves token exchange
  - JWT (JSON Web Tokens): Tokens that are signed and can be used to verify the identity of the user
** rate limiting
- a mechanism to control the number of requests a client can make to the API in a given time period. This helps prevent abuse and ensures fair usage.
** versioning
- APIs often have versions to manage changes and updates without breaking existing clients. Versioning can be done through the URL (e.g., https://api.example.com/v1/users) or headers.
** documentation
- comprehensive documentation is crucial for developers to understand how to use the API. it typically includes details about endpoints, request/response formats, authentication, and examples.

* getting started in python
** installation
- pip install Flask
- mkdir hello_world_api
- cd hello_world_api
** application
- open app.py
- from flask import Flask

  app = Flask(__name__)

  @app.route('/')
  def hello_world():
      return 'Hello, World!'

  if __name__ == '__main__':
     app.run(host='0.0.0.0', port=5000)
- This code sets up a basic Flask application with a single route (/) that returns "Hello, World!".
- The app.run() function starts the Flask development server, listening on all interfaces (0.0.0.0) and port 5000.
** run
- python app.py
- Access the API: Once the server is running, you can access the API from a web browser or any HTTP client (like curl or Postman) using the URL http://<your-server-ip>:5000/. If you're running it locally, you can use http://localhost:5000/.
** test the api
- curl http://localhost:5000/
** deploy
- To make your API accessible to remote clients, you need to deploy it to a server. You can use cloud services like AWS, Heroku, or any other hosting provider that supports Python applications. Hereâ€™s a brief overview of deploying on AWS:
  - Set up an EC2 instance: Launch an EC2 instance with a Linux distribution.
  - Install Python and Flask on the instance.
  - Transfer your application files to the server using SCP or any other file transfer method.
  - Run the Flask application on the server, ensuring that the security group allows inbound traffic on port 5000.
  - Access the API using the public IP address of your EC2 instance.
- This setup provides a simple way to expose a "Hello, World!" program via an API. For production use, consider using a production-ready server like Gunicorn and a reverse proxy like Nginx.
** secure copy protocol (scp)
- scp [options] source_file user@host:destination_path
- scp /path/to/local/file.txt user@remote_host:/path/to/remote/directory/
- scp user@remote_host:/path/to/remote/file.txt /path/to/local/directory/
- scp -r /path/to/local/directory user@remote_host:/path/to/remote/directory/
*** common options:
-r: Recursively copy entire directories.
-P: Specify a port number to connect to on the remote host.
-i: Specify an identity file (private key) to use for authentication.
